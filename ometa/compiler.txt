// ----------------------------------------------------------------------------
//
//
//                              Generic AST Algorithms and Tools
//
//
// ----------------------------------------------------------------------------
ometa PhotonASTTraversal {
  trans      = [:t apply(t):ans],

  global   :ctxt trans:r,
  this end,                                                  
  break end,                                                 
  continue end,
  number   :n,
  string   :s,
  arr      trans*:xs,
  unop     :op trans:x,
  getp     trans:x trans:fd,
  get      :x,
  set      trans:lhs trans:rhs,
  mset     trans:lhs :op trans:rhs,
  binop    :op trans:x trans:y,
  preop    :op trans:x,
  postop   :op trans:x,
  return   trans:x,
  with     trans:x trans:s,
  if       trans:cond trans:t trans:e,
  condExpr trans:cond trans:t trans:e,
  while    trans:cond trans:body,
  doWhile  trans:body trans:cond,
  for      trans:init trans:cond trans:upd
           trans:body,
  forIn    trans:x trans:arr trans:body,
  begin    trans:x end,
  begin    trans*:xs,
  func     :args :ctxt trans:body,  
  funcStmt :name trans:fct,  
  call     trans:fn trans*:args,
  ccall    trans:fn trans*:args,
  send     :msg trans:recv trans*:args,
  new      trans:fn trans*:args,
  var      :name trans:val,
  throw    trans:x,
  try      :ctxt trans:x :name trans:c trans:f,
  json     trans*:props,
  binding  trans:name trans:val,
  switch   trans:x trans*:cases,
  case     trans:x trans:y,
  default          trans:y,
  regexp   :e,
  exprSeq  trans*:es,

  ref      :s,
  gets     trans:x trans:fd,
  mreturn  trans:x trans:y,
  code     :c,
  super    trans:e,
  macro    :n :args :ctxt trans:body,
  letvar   [#var :name trans],
  let      :ctxt [#begin letvar*] trans,
  super_send :msg trans:rcv trans*:args,
  closure end,
  arguments trans:i,
  arguments_length end,
  arguments_slice trans:i end,
  closureRef trans:fn trans:offset,
  closureRefValue trans:fn trans:offset,
  getCell  :id,
  postcode trans:x :s,
  precode  :s trans:x,
  igetp    trans:x trans:fd,
  letLambda :args [trans*:values] trans:body,
  icSend   :nb :msg trans:recv trans*:args,
  wrapExpr :pre :post trans:e
}

ometa PhotonASTCopy {
  trans      = [:t apply(t):ans]      -> ans,

  global   :ctxt trans:r                        -> [#global, ctxt, r],
  this end                                      -> [#this],    
  break end                                     -> [#break],
  continue end                                  -> [#continue],
  number   :n                                   -> [#number, n],
  string   :s                                   -> [#string, s],
  arr      trans*:xs                            -> [#arr].concat(xs),
  unop     :op trans:x                          -> [#unop, op, x],
  getp     trans:x trans:fd                     -> [#getp, x, fd],
  get      :x                                   -> [#get, x],
  set      trans:lhs trans:rhs                  -> [#set, lhs, rhs],
  mset     trans:lhs :op trans:rhs              -> [#mset, lhs, op, rhs],
  binop    :op trans:x trans:y                  -> [#binop, op, x, y],
  preop    :op trans:x                          -> [#preop, op, x],
  postop   :op trans:x                          -> [#postop, op, x],
  return   trans:x                              -> [#return, x],
  with     trans:x trans:s                      -> [#with, x, s],
  if       trans:cond trans:t trans:e           -> [#if, cond, t, e],
  condExpr trans:cond trans:t trans:e           -> [#condExpr, cond, t, e],
  while    trans:cond trans:body                -> [#while, cond, body],
  doWhile  trans:body trans:cond                -> [#doWhile, body, cond],
  for      trans:init trans:cond trans:upd 
           trans:body                           -> [#for, init, cond, upd, body],
  forIn    trans:x trans:arr trans:body         -> [#forIn, x, arr, body],
  begin    trans:x end                          -> [#begin, x],
  begin    trans*:xs                            -> [#begin].concat(xs),
  func     :args :ctxt trans:body               -> [#func, args, ctxt, body],  
  funcStmt :name trans:fct                      -> [#funcStmt, name, fct],
  call     trans:fn trans*:args                 -> [#call, fn].concat(args),
  ccall    trans:fn trans*:args                 -> [#ccall, fn].concat(args),
  send     :msg trans:recv trans*:args          -> [#send, msg, recv].concat(args),
  new      trans:fn trans*:args                 -> [#new, fn].concat(args),
  var      :name trans:val                      -> [#var, name, val],
  throw    trans:x                              -> [#throw, x],
  try      :ctxt trans:x :name trans:c trans:f  -> [#try, ctxt, x, name, c, f],
  json     trans*:props                         -> [#json].concat(props),
  binding  trans:name trans:val                 -> [#binding, name, val],
  switch   trans:x trans*:cases                 -> [#switch, x].concat(cases),
  case     trans:x trans:y                      -> [#case, x, y],
  default          trans:y                      -> [#default, y],
  regexp   :e                                   -> [#regexp, e],
  exprSeq  trans*:es                            -> [#exprSeq].concat(es),

  ref      :s                                   -> [#ref, s],
  gets     trans:x trans:fd                     -> [#gets, x, fd],
  mreturn  trans:x trans:y                      -> [#mreturn, x, y],
  code     :c                                   -> [#code, c],
  super    trans:e                              -> [#super, e],
  macro    :n :args :ctxt trans:body            -> [#macro, n, args, ctxt, body],
  letvar   [#var :name trans:val]               -> [#var, name, val],
  let      :ctxt [#begin letvar*:vs] trans:body -> [#let, ctxt, [#begin].concat(vs), body],
  super_send :msg trans:rcv trans*:args         -> [#super_send, msg, rcv].concat(args),
  closure end                                   -> [#closure],
  arguments trans:i                             -> [#arguments, i],
  arguments_length end                          -> [#arguments_length],
  arguments_slice trans:i end                   -> [#arguments_slice, i],
  closureRef trans:fn trans:offset              -> [#closureRef, fn, offset],
  closureRefValue trans:fn trans:offset         -> [#closureRefValue, fn, offset],
  getCell  :id                                  -> [#getCell, id],
  postcode trans:x :s                           -> [#postcode, x, s],
  precode  :s trans:x                           -> [#precode, s, x],
  igetp    trans:x trans:fd                     -> [#igetp, x, fd],
  letLambda :args [trans*:values] trans:body    -> [#letLambda, args, [values], body],
  icSend   :nb :msg trans:recv trans*:args      -> [#icSend, nb, msg, recv].concat(args),
  wrapExpr :pre :post trans:e                   -> [#wrapExpr, pre, post, e]
}

ometa PhotonPrettyPrinter 
{
  trans      = [:t apply(t):ans]    -> ans,
  flatten :a = [#begin flatten(a)*]
               | stmt:x                     -> a.push((self.ilvl() + x + "\n"))
               | trans:x                    -> a.push((self.ilvl() + x + ";\n")),
  flat       = {[]}:stmts flatten(stmts)*     -> stmts.join(""),
  stmt       = [:t isStmt(t) apply(t):ans]    -> ans,
  isStmt :t  = ?(self.stmts[t] !== undefined),
  block      = inc blockBody:body dec -> (self.ilvl() + "{\n" + body + self.ilvl() + "}"),
  blockBody  = [:t ?(t === "begin") apply("begin"):ans] -> ans
               | stmt:x                                 -> (self.ilvl() + x + "\n")
               | trans:x                                -> (self.ilvl() + x + ";\n"),
  exprList   = [#begin ([#var :name trans:val] -> (name + " = " + val))*:es] -> ("var " + es.join(", "))
             | [#begin trans*:es]                                            -> es.join(", "),
  inc        = { self.i++; },
  dec        = { self.i--; },
  
  global   :ctxt trans:r                                           -> r,
  this end                                                         -> "this", 
  break end                                                        -> "break", 
  continue end                                                     -> "continue",
  number   :n                                                      -> String(n),
  string   :s                                                      -> s.toProgramString(),
  arr      trans*:xs                                               -> ("[" +  xs.join(",") +  "]"),
  unop     :op trans:x                                             -> ("(" + op + " " +  x + ")"),
  getp     trans:x trans:fd                                        -> (x +  "[" +  fd +  "]"),
  get      :x                                                      -> x,
  set      trans:lhs trans:rhs                                     -> (lhs +  " = " +  rhs),
  mset     trans:lhs :op trans:rhs                                 -> (lhs +  " " +  op +  "=" +  rhs),
  binop    :op trans:x trans:y                                     -> ("(" + x +  " " +  op +  " " +  y + ")"),
  preop    :op trans:x                                             -> ("(" + op + x + ")"),
  postop   :op trans:x                                             -> ("(" + x + op + ")"),
  return   trans:x                                                 -> ("return " +  x),
  with     trans:x block:s                                         -> ("with (" +  x +  ")\n" +  s),
  if       trans:cond block:t block:e                              -> ("if (" +  cond +  ")\n" + t + " else\n" + e),
  condExpr trans:cond trans:t trans:e                              -> ("(" +  cond +  ") ? " +  t +  " : " +  e),
  while    trans:cond block:body                                   -> ("while (" +  cond +  ")\n" +  body),
  doWhile  block:body trans:cond                                   -> ("do \n" +  body +  "while (" +  cond +  ")"),
  for      exprList:init trans:cond exprList:upd block:body        -> ("for (" +  init +  "; " +  cond +  "; " +  upd +  ")\n" +  body),
  forIn    trans:x trans:arr block:body                            -> ("for (" +  x +  " in " +  arr +  ")\n" +  body),
  begin    flat:stmts                                              -> stmts,
  func     :args :ctxt block:body                                  -> ("(function (" +  args.join(",") +  ")\n" + body + ")"),
  call     trans:fn trans*:args                                    -> (fn +  "(" +  args.join(",") +  ")"),
  send     :msg trans:recv trans*:args                             -> (recv +  "." +  msg +  "(" +  args.join(", ") +  ")"),
  new      trans:fn trans*:args                                    -> ("new " +  fn +  "(" +  args.join(", ") +  ")"),
  var      :name ( [#get #undefined] -> ""
                 | trans:val         -> (" = " + val)):v           -> ("var " + name + v),
  throw    trans:x                                                 -> ("throw " +  x),
  try      :ctxt block:x :name block:c block:f                     -> ("try\n" + x + " catch (" + name + ")\n" + c ),
  json     inc trans*:props dec                                    -> ("{\n" +  props.join(",\n") +  "\n" + self.ilvl() + "}"),
  binding  trans:name trans:val                                    -> (self.ilvl() + name +  ":" +  val),
  switch   trans:x inc trans*:cases dec                            -> ("switch (" +  x +  ")\n" +  self.ilvl() +  "{\n" +  cases.join("\n") +  self.ilvl() +  "}"),
  case     trans:x inc block:y dec                                 -> (self.ilvl() + "case " +  x +  ":\n" + y),
  default          inc block:y dec                                 -> (self.ilvl() + "default:\n" +  y),

  ccall    :fn (:x)*:args                                          -> ("@{[#ccall, " + fn + ", " +  args.join(", ") + "]}@"),
  global_return    trans:x                                         -> ("global_return " +  x),
  ref      :s                                                      -> ("@{[#ref, " +  (s.hasOwnProperty("pp") && (typeof s.pp) === "function" ? s.pp() : "[object]") +  "]}@"),
  gets     trans:x trans:fd                                        -> (x +  "[@" +  fd +  "]"),
  mreturn  :x :y                                                   -> ("@{[#mreturn, " +  x +  ", " +  y + "]}@"),
  code     :c                                                      -> ("@{[#code, " +  c.map(function (e) { return "[native code]"; }).join("\n") +  "]}@"),
  super    trans:e                                                 -> ("super(" +  e + ")"),
  macro    :n :args :ctxt block:body                               -> ("macro " + n + "(" + args.join(",") + ")\n" + body),
  letvars  [#begin 
             ( [#var :name trans:val] -> (name + " = " + val)
             | trans)*:es] -> (es.join(", ")),
  let      :ctxt letvars:es block:body                             -> ("(let (" + es + ")\n" + body + ")"),
  closure                                                          -> ("$closure"),
  super_send :msg trans:recv trans*:args                           -> ("super(" + recv + ")." + msg + "(" + args.join(" ,") + ")"),
  arguments trans:i end                                            -> ("$arguments[@" + i + "]"),
  arguments_length end                                             -> ("$arguments_length")

}

PhotonPrettyPrinter.initialize = function ()
{
    this.i     = 0;
    this.sp    = [""];
    this.stmts = {"if":true, "while":true, "for":true, "forIn":true, "try":true, "switch":true, "with":true};
    this.ilvl  = function () 
    {
        while (this.i >= this.sp.length) 
        { 
            this.sp.push(this.sp[this.sp.length - 1] + "    "); 
        } 
        return this.sp[this.i];
    };
};

// ----------------------------------------------------------------------------
//
//
//                              Lexer and Parser
//
//
// ----------------------------------------------------------------------------
ometa PhotonParser <: Parser {
  fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 
  fromTo2 :x :y = seq(x) (~seq(y) char)*:s seq(y) -> s.join(''), 
  space        = ^space | fromTo('//', '\n') | fromTo('/*', '*/'),
  ceval        = fromTo2('@{', '}@'):s                                               -> [#eval, s],
  nameFirst    = letter | '$' | '_',
  nameRest     = nameFirst | digit,
  iName        = firstAndRest(#nameFirst, #nameRest):r                               -> r.join(''),
  isKeyword :x = ?self._isKeyword(x),
  name         = iName:n ~isKeyword(n)                                               -> [#name, n],
  keyword      = iName:k isKeyword(k)                                                -> [k, k],
  hexDigit     = char:x {this.hexDigits.indexOf(x.toLowerCase())}:v ?(v >= 0)        -> v,
  hexLit       = hexLit:n hexDigit:d                                                 -> (n * 16 + d)
               | hexDigit,
  intDigit     = char:x {this.hexDigits.indexOf(x.toLowerCase())}:v ?(v >= 0)        -> v,
  intLit       = intLit:n intDigit:d                                                 -> (n * 10 + d)
               | intDigit,
  number       = ``0x'' hexLit:n                                                     -> [#number, n]
               | digit+:ws ('.' digit+ | empty -> []):fs 
                 ( ('e' ('+' | '-' | empty -> ''):sign digit+:ds -> {['e', sign].concat(ds)})
                   | {[]}):es                                                        -> [#number, parseFloat(ws.join('') + '.' +
                                                                                                             fs.join('') + es.join(''))]
               | intLit:n                                                            -> [#number, n],
  escapeChar   = ( ``\\x'' char:c1 char:c2                 -> ('x'+c1+c2) 
                 | ``\\u'' char:c1 char:c2 char:c3 char:c4 -> ('u'+c1+c2+c3+c4)
                 | ``\\\n''                                -> ''                                     
                 |   '\\'  char):c                                                   -> unescape('\\' + c),

  str          = seq('"""')  (escapeChar | ~seq('"""') char)*:cs seq('"""')          -> [#string, cs.join('')]
               | '\'' (escapeChar | ~'\'' char)*:cs '\''                             -> [#string, cs.join('')]
               | '"'  (escapeChar | ~'"'  char)*:cs '"'                              -> [#string, cs.join('')]
               | ('#' | '`') iName:n                                                 -> [#string, n],
  special      = ( '('   | ')'    | '{'    | '}'     | ``[@'' |'['      | ']'     | ','    
                 | ';'   | '?'    | ':'    | ``!=='' | ``!='' | ``==='' | ``==''
                 |``<<=''| ``<<'' |``>>>='' |``>>>'' |``>>=''  |``>>'' 
                 | ``='' | ``>='' | '>'    | ``<=''  | '<'    | ``++''  | ``+=''
                 | '+'   | ``--'' | ``-='' | '-'     | ``*='' | '*'     | ``/=''
                 | '/'   | ``%='' | '%'    | ``&&='' | ``&='' | ``&&''  | ``||='' 
                 | ``|=''| ``||'' | ``^=''
                 | '.'   | '!'    | '|'    | '&'     | '^'    | '~'              ):s -> [s, s],
  tok          = spaces (ceval | name | keyword | number | str | special),
  toks         = token*:ts spaces end                                                -> ts,
  token :tt    = tok:t ?(t[0] === tt)                                                -> t[1],
  spacesNoNl   = (~'\n' space)*,
  expr         = orExpr:e ( "?"   expr:t   ":" expr:f                                -> [#condExpr, e, t, f]
                          | "="   expr:rhs                                           -> [#set, e, rhs]
                          | "+="  expr:rhs                                           -> [#mset, e, "+", rhs]
                          | "-="  expr:rhs                                           -> [#mset, e, "-", rhs]
                          | "*="  expr:rhs                                           -> [#mset, e, "*", rhs]
                          | "/="  expr:rhs                                           -> [#mset, e, "/", rhs]
                          | "%="  expr:rhs                                           -> [#mset, e, "%", rhs]
                          | "&&=" expr:rhs                                           -> [#mset, e, "&&", rhs]
                          | "||=" expr:rhs                                           -> [#mset, e, "||", rhs]
                          | "|="  expr:rhs                                           -> [#mset, e, "|", rhs]
                          | "&="  expr:rhs                                           -> [#mset, e, "&", rhs]
                          | "^="  expr:rhs                                           -> [#mset, e, "^", rhs]
                          | ">>>="  expr:rhs                                         -> [#mset, e, ">>>", rhs]
                          | ">>="  expr:rhs                                          -> [#mset, e, ">>", rhs]
                          | "<<="  expr:rhs                                          -> [#mset, e, "<<", rhs]
                          | empty                                                    -> e
                          ),
  orExpr       = orExpr:x "||" andExpr:y                                             -> [#binop, "||", x, y]
               | andExpr,
  andExpr      = andExpr:x "&&" bitExpr:y                                            -> [#binop, "&&", x, y]
               | bitExpr,
  bitExpr      = bitExpr:x "|" eqExpr:y                                              -> [#binop, "|", x, y]
               | bitExpr:x "^" eqExpr:y                                              -> [#binop, "^", x, y]
               | bitExpr:x "&" eqExpr:y                                              -> [#binop, "&", x, y]
               | eqExpr,
  eqExpr       = eqExpr:x ( "=="  relExpr:y                                          -> [#binop, "==",  x, y]
                          | "!="  relExpr:y                                          -> [#binop, "!=",  x, y]
                          | "===" relExpr:y                                          -> [#binop, "===", x, y]
                          | "!==" relExpr:y                                          -> [#binop, "!==", x, y]
                          )
               | relExpr,
  relExpr      = relExpr:x ( ">"          sftExpr:y                                  -> [#binop, ">",          x, y]
                           | ">="         sftExpr:y                                  -> [#binop, ">=",         x, y]
                           | "<"          sftExpr:y                                  -> [#binop, "<",          x, y]
                           | "<="         sftExpr:y                                  -> [#binop, "<=",         x, y]
                           | "in"         sftExpr:y                                  -> [#binop, "in",         x, y]
                           | "instanceof" sftExpr:y                                  -> [#binop, "instanceof", x, y]
                           )
               | sftExpr,
  sftExpr      = sftExpr:x ">>>" addExpr:y                                           -> [#binop, ">>>",        x, y]
               | sftExpr:x ">>"  addExpr:y                                           -> [#binop, ">>",         x, y]
               | sftExpr:x "<<"  addExpr:y                                           -> [#binop, "<<",         x, y]
               | addExpr,
  addExpr      = addExpr:x "+" mulExpr:y                                             -> [#binop, "+",          x, y]
               | addExpr:x "-" mulExpr:y                                             -> [#binop, "-",          x, y]
               | mulExpr,
  mulExpr      = mulExpr:x "*" unary:y                                               -> [#binop, "*",          x, y]
               | mulExpr:x "/" unary:y                                               -> [#binop, "/",          x, y]
               | mulExpr:x "%" unary:y                                               -> [#binop, "%",          x, y]
               | unary,
  unary        = "-"      postfix:p                                                  -> [#unop,  "-",        p]
               | "+"      postfix:p                                                  -> [#unop,  "+",        p]
               | "++"     postfix:p                                                  -> [#preop, "++", p] 
               | "--"     postfix:p                                                  -> [#preop, "--", p]
               | "!"      unary:p                                                    -> [#unop,  "!",        p]
               | "void"   unary:p                                                    -> [#unop,  "void",     p]
               | "delete" unary:p                                                    -> [#unop,  "delete",   p]
               | "typeof" unary:p                                                    -> [#unop,  "typeof",   p]
               | "~"      unary:p                                                    -> [#unop,  "~",        p]
               | postfix,
  postfix      = primExpr:p ( spacesNoNl ( "++" -> "++"
                                         | "--" -> "--" ):op                         -> [#postop, op, p] 
                            | empty                                                  -> p
                            ),
  primExpr     = primExpr:p ( "[@" expr:i "]"                                        -> [#gets, p, i]
                            | "["  expr:i "]"                                        -> [#getp, p, i]
                            | "." ("name":n
                                  | keyword:k -> k[0]):f                             -> [#getp, p, [#string, f]]
                            | "(" listOf(#expr, ','):as ")"                          -> [#call, p].concat(as)
                            )
               | newExpr 
               | primExprHd,
               
  newExpr      = "new" ( innerNewExpr:e "(" listOf(#expr, ','):as ")" 
                       | innerNewExpr:e {[]}:as )                                    -> [#new, e].concat(as),

  innerNewExpr = innerNewExpr:p  ( "[@" expr:i "]"                                   -> [#gets, p, i]
                            | "["  expr:i "]"                                        -> [#getp, p, i]
                            | "." ("name":n
                                  | keyword:k -> k[0]):f                             -> [#getp, p, [#string, f]]
                            )
               | newExpr
               | primExprHd,

  regexpEsc    = ``\\\\'' -> '\\\\'
               | ``\\/''  -> '\\/',
  primExprHd   = "super" "(" expr:e ")"                                              -> [#super, e] 
               | "(" listOf(#expr, ','):es ")"                                       -> (es.length === 1 ? es[0] : [#exprSeq].concat(es))
               | "this"                                                              -> [#this]
               | "$closure"                                                          -> [#closure]
               | "$arguments" "[" expr:i "]"                                         -> [#arguments, i]
               | "$arguments_length"                                                 -> [#arguments_length]
               | "$arguments_slice" "(" expr:i ")"                                   -> [#arguments_slice, i]
               | "name":n                                                            -> [#get, n]
               | "number":n                                                          -> [#number, n]
               | "string":s                                                          -> [#string, s]
               | spaces '/' ( regexpEsc | ~'/' char )+:re '/'
                 ('g' | 'i' | 'm' | 'y' | empty -> ''):c1 
                 ('g' | 'i' | 'm' | 'y' | empty -> ''):c2                            -> [#regexp, '/'+re.join('')+'/'+c1+c2]
               | "eval":s                                                            -> eval(s)
               | "function" funcRest
               | "let" "(" listOf(#binding, ','):bs ")" stmt:s                       -> [#let, _new_context(), [#begin].concat(bs), s]
               | "[" listOf(#expr, ','):es "]"                                       -> [#arr].concat(es)
               | json,
  json         = "{" listOf(#jsonBinding, ','):bs "}"                                -> [#json].concat(bs),
  jsonBinding  = jsonPropName:n ":" expr:v                                           -> [#binding, n, v],
  jsonPropName = "name":n   -> [#string, n] 
               | "number":n -> [#number, n]
               | "string":s -> [#string, s],
  formal       = spaces "name",
  funcRest     = "(" listOf(#formal, ','):fs ")" "{" srcElems:body "}"               -> [#func, fs, _new_context(), body],
  sc           = spacesNoNl ('\n' | &'}' | end)
               | ";",
  binding      = "name":n ( "=" expr
                          | empty -> [#get, 'undefined'] ):v                         -> [#var, n, v],
  block        = "{" srcElems:ss "}"                                                 -> ss,
  stmt         = block
               | ("var" | "const") listOf(#binding, ','):bs sc                       -> [#begin].concat(bs)
               | "if" "(" expr:c ")" stmt:t ( "else" stmt
                                            | empty -> [#get, 'undefined'] ):f       -> [#if, c, t, f]
               | "while" "(" expr:c ")" stmt:s                                       -> [#while,   c, s]
               | "do" stmt:s "while" "(" expr:c ")" sc                               -> [#doWhile, s, c]
               | "for" "(" ( "var" listOf(#binding, ','):bs   -> [#begin].concat(bs)
                           | listOf(#expr, ','):es            -> [#begin].concat(es)
                           | empty -> [#get, 'undefined'] ):i
                       ";" ( expr
                           | empty -> [#get, 'true']      ):c
                       ";" ( listOf(#expr, ','):es            -> [#begin].concat(es)
                           | empty -> [#get, 'undefined'] ):u
                       ")" stmt:s                                                    -> [#for, i, c, u, s]
               | "for" "(" ( "var" binding:v "in" expr:e
                           | expr:fe ?(fe[0] === #binop && fe[1] === #in) {fe[2]}:v {fe[3]}:e )
                       ")" stmt:s                                                    -> [#forIn, v, e, s]
               | "switch" "(" expr:e ")" "{"
                   ( "case" expr:c ":" srcElems:cs -> [#case, c, cs]
                   | "default"     ":" srcElems:cs -> [#default, cs] )*:cs
                 "}"                                                                 -> [#switch, e].concat(cs)
               | "break" sc                                                          -> [#break]
               | "continue" sc                                                       -> [#continue]
               | "throw" spacesNoNl expr:e sc                                        -> [#throw, e]
               | "try" block:t 
                    ("catch" "(" ("name" | (empty -> undefined)):e ")" block:c
                             ( "finally" block
                             | empty -> [#get, 'undefined'] ):f
                    | "finally" block:f (empty -> [#begin]):c (empty -> undefined):e)
                                                                                     -> [#try, _new_context(), t, e, c, f]
               | "return" ( expr
                          | empty -> [#get, 'undefined'] ):e sc                      -> [#return, e]
               | "global_return" ( expr
                          | empty -> [#get, 'undefined'] ):e sc                      -> [#global_return, e]
               | "with" "(" expr:x ")" stmt:s                                        -> [#with, x, s]
               | expr:e sc                                                           -> e
               | ";"                                                                 -> [#get, "undefined"],
  srcElem      = "function" "name":n funcRest:f                                      -> {f[2].name = n; [#funcStmt, n, f]}
               | "macro" "name":n funcRest:f                                         -> [#macro, n].concat(f.slice(1))
               | stmt,
  srcElems     = srcElem*:ss                                                         -> [#begin].concat(ss),
  topLevel     = srcElems:r spaces end                                               -> [#global, _new_context(), r]
}

PhotonParser.initialize = function ()
{
    this.hexDigits = "0123456789abcdef";
    this.keywords  = { };
    var keywords = ["break", "case", "catch", "continue", "default", "delete", "do", 
                "else", "finally", "for", "function", "if", "in", "instanceof", 
                "new", "return", "switch", "this", "throw", "try", "typeof", "var", 
                "void", "while", "with", "ometa", "const", "global_return", "macro", 
                "super", "let", "$closure", "$arguments", "$arguments_length", "$arguments_slice"];
    for (var idx = 0; idx < keywords.length; idx++)
    {
      this.keywords[keywords[idx]] = true
    }
    this._isKeyword = function(k) { return this.keywords.hasOwnProperty(k) }
};

// To allow the Parser to be tested without loading photon-lib.js
function _new_context() { return {}; }

// ----------------------------------------------------------------------------
//
//
//                              Macro Expansion
//
//
// ----------------------------------------------------------------------------

ometa PhotonMacroExp <: PhotonASTCopy {
  macro    :n  :args :ctxt :body                      -> {self.macros[n] = [#macro, n, args, ctxt, body]; 
                                                          [#begin]},
  call     ([#get :x] ?(self.macros[x] !== undefined) 
           trans*:args                                -> PhotonMacroRep
                                                         .createInstance(args, self.macros)
                                                         .match(self.macros[x], "trans")
           | ^call)
}

PhotonMacroExp.initialize = function ()
{
    this.macros = {};
}

ometa PhotonMacroRep <: PhotonASTCopy {
  get      (:x ?(self.bindings[x] !== undefined)      -> self.bindings[x]
           | ^get),
             
  macro    :n  (:args -> self.bind(args)) :ctxt 
                  trans:body                          -> body,
  begin    [#return trans:x] end                      -> x,
  begin    trans:x end                                -> [#begin, x],
  begin    trans*:xs                                  -> [#begin].concat(xs),
 
  // Recursively expand macro calls
  call     ([#get :x] ?(self.macros[x] !== undefined) 
           trans*:args                                -> self.createInstance(args, self.macros).match(self.macros[x], "trans")
           | ^call)
}

PhotonMacroRep.initialize = function (args, macros)
{
    this.macro_actual_args = args;
    this.macros = macros;
    this.bindings = {};
    this.bind = function (args)
    {
        for (var i=0; i < args.length; ++i)
        {
            this.bindings[args[i]] = this.macro_actual_args[i];
        }
    }
}

// ----------------------------------------------------------------------------
//
//
//                              AST Simplification
//
//
// ----------------------------------------------------------------------------
ometa PhotonDesugar <: PhotonASTCopy {

  global   :ctxt 
           {self.context.enter_function_scope();}
           trans:r                                      
           {self.context.leave_function_scope("global");}:vs  -> {var ast;
                                                                  if (photon.genTryCatch) {
                                                                      var e = gensym(); var try_ctxt = _new_context(); 
                                                                      ast = [#global, ctxt, 
                                                                        [#try, _new_context(), 
                                                                            [#begin].concat(vs).concat(r.slice(1)),
                                                                            e,
                                                                            [#begin, 
                                                                                [#code, "print(" + e + ".stack)"],
                                                                                [#call, [#get, "print"], [#string, "Unhandled exception:"]],
                                                                                [#call, [#get, "print"], [#get, e]],
                                                                                [#throw, [#get, e]]],
                                                                            [#get, #undefined]]]
                                                                  } else {
                                                                      ast = [#global, ctxt, [#begin].concat(vs).concat(r.slice(1))]; 
                                                                  } 
                                                                  ast},
  func     :args :ctxt 
           {self.context.enter_function_scope(); args = self.context.replace_arguments(args); self.context.args(args);} 
           trans:body
           {self.context.leave_function_scope();}:vs          -> [#func, args, ctxt, [#begin].concat(vs).concat(body.slice(1))],
  funcStmt :name {self.context.declare(name)} trans:fct       -> {self.context.fct_env.push([name,fct]); [#begin]},
  var      :name {self.context.declare(name)}
                 ( [#get #undefined]                          -> [#begin]
                 | trans:val                                  -> [#set, [#get, name], val]),
  /*
  arr      trans*:xs                                          -> {var a = gensym(); 
                                                                  [#let, _new_context(), 
                                                                    [#begin, 
                                                                        [#var, a, [#send, "__new__", [#ref, "root.array"], [#number, xs.length]]]],
                                                                    [#begin]
                                                                    .concat(xs.map(function (x) {
                                                                     return [#send, "push", [#get, a], x];}))
                                                                    .concat([[#get, a]])]},
  */
  unop     ( 'typeof' [#get 'window']                         -> [#string, "undefined"] 
           | 'typeof' trans:x                                 -> [#send, "__typeof__",  x]
           | 'delete' ( [#getp trans:x trans:f]               -> [#send, "__delete__",  x, f]
                      | [#get :n]                             -> [#get, #false])
           | ^unop), 
  binop    ( 'instanceof' trans:x trans:y                     -> [#send, "__instanceof__", x, y]
           | 'in'         trans:x trans:y                     -> [#send, "__in__", y, x]
           | ^binop),
  getp     trans:x trans:fd                                   -> [#send, "__get__", x, fd],
  mset     ( ([#getp trans:rcv trans:fd]):lhs :op trans:rhs   -> {var id_rcv = gensym(); var id_fd = gensym();
                                                                  [#let, _new_context(),
                                                                    [#begin,
                                                                        [#var, id_rcv, rcv],
                                                                        [#var, id_fd, fd]],
                                                                    [#begin,
                                                                        [#send, "__set__", 
                                                                            [#get, id_rcv], 
                                                                            [#get, id_fd], 
                                                                            [#binop, op, 
                                                                                [#send, "__get__", 
                                                                                    [#get, id_rcv], 
                                                                                    [#get, id_fd]], 
                                                                                rhs]]]]}
           | trans:lhs                        :op trans:rhs   -> [#set, lhs, [#binop, op, lhs, rhs]]),
  preop    ( '++' -> "+" | '--' -> "-"):op 
           ( [#getp trans:rcv trans:fd]:x                     -> {var id_rcv = gensym(); var id_fd = gensym();
                                                                  [#let, _new_context(),
                                                                    [#begin,
                                                                        [#var, id_rcv, rcv],
                                                                        [#var, id_fd, fd]],
                                                                    [#begin,
                                                                        [#send, "__set__", 
                                                                            [#get, id_rcv], 
                                                                            [#get, id_fd], 
                                                                            [#binop, op, 
                                                                                [#send, "__get__", 
                                                                                    [#get, id_rcv], 
                                                                                    [#get, id_fd]], 
                                                                                [#number, 1]]]]]}
           | trans:x                                          -> [#set, x, [#binop, op, x, [#number, 1]]]),
  postop   ( '++' -> "+" | '--' -> "-"):op                     
           ( [#getp trans:rcv trans:fd]:x                     -> {var id_rcv = gensym(); var id_fd = gensym(); var id_r = gensym();
                                                                  [#let, _new_context(),
                                                                    [#begin,
                                                                        [#var, id_rcv, rcv],
                                                                        [#var, id_fd, fd]],
                                                                    [#begin,
                                                                        [#let, _new_context(),
                                                                            [#begin,
                                                                                [#var, id_r, 
                                                                                    [#send, "__get__", 
                                                                                        [#get, id_rcv], 
                                                                                        [#get, id_fd]]]],
                                                                            [#begin,
                                                                                [#send, "__set__", 
                                                                                    [#get, id_rcv], 
                                                                                    [#get, id_fd], 
                                                                                    [#binop, op, 
                                                                                        [#get, id_r],
                                                                                        [#number, 1]]],
                                                                                [#get, id_r]]]]]}
           | trans:x                                          -> {var id = gensym();
                                                                  [#let, _new_context(),
                                                                    [#begin, 
                                                                        [#var, id, x]],
                                                                    [#begin,
                                                                        [#set, x, [#binop, op, [#get, id], [#number, 1]]],
                                                                        [#get, id]]]}),  
  forIn     ( [#get :name] 
            | [#var :name [#get #undefined]] -> {self.context.declare(name)}) 
            trans:arr trans:body                              -> {var it = gensym();
                                                                  [#let, _new_context(),
                                                                    [#begin, 
                                                                        [#var, it, [#send, "__itr__", arr]]],
                                                                    [#begin,
                                                                        [#while, [#send, "valid", [#get, it]],
                                                                            [#begin, 
                                                                                [#set, [#get, name], [#send, "get",  [#get, it]]]]
                                                                                .concat([body])
                                                                                .concat([[#send, "next", [#get, it]]])],
                                                                        [#get, "undefined"]]]},
  new      trans:fn trans*:args                               -> [#send, "__ctor__", fn].concat(args),
  /*
  json     trans*:props                                       -> {var o = gensym();
                                                                  [#let, _new_context(), 
                                                                    [#begin, [#var, o, [#send, "__new__", [#ref, "root.object"]]]],
                                                                    ([#begin]
                                                                    .concat(props.map(function (b) { 
                                                                     return [#send, "__set__", 
                                                                                    [#get, o], 
                                                                                    b[1],
                                                                                    b[2]];}))
                                                                    .concat([[#get, o]]))]},
  */
  call     = [#getp [#super trans:rcv] ( [#string :msg] 
                                       | { error("Super send need a static message name"); } ) ] 
             trans*:args                                      -> [#super_send, msg, rcv].concat(args)
           | [#getp trans:rcv [#string :msg]]  trans*:args    -> [#send, msg, rcv].concat(args)
           | [#getp trans:rcv trans:msg]       trans*:args    -> {var id_rcv = gensym();
                                                                  [#let, _new_context(),
                                                                     [#begin,
                                                                         [#var, id_rcv, rcv]],
                                                                     [#begin,
                                                                        [#send, "call", 
                                                                            [#send, "__get__", 
                                                                                [#get, id_rcv], 
                                                                                msg],
                                                                            [#get, id_rcv]]
                                                                            .concat(args)]]}           
           |  ^call,
  set      ( [#getp trans:rcv trans:fd] trans:rhs             -> [#send, "__set__", rcv, fd, rhs]
           | ^set),
  get      ( :name ?(name === "arguments")                    -> {self.context.declare("$arguments"); [#get, "$arguments"]}
           | ^get)
}

PhotonDesugar.initialize = function ()
{
    this.context = PhotonDesugar.context.init();
};
PhotonDesugar.context = {
    init:function () {
        var that = Object.create(PhotonDesugar.context);
        that.scope = null;
        that.previous_scopes = [];
        that.fct_env = null;
        that.previous_fct_env = [];
        return that;
    }, 
    enter_function_scope:function () {
        this.previous_scopes.push(this.scope);    
        this.scope = {};
        this.previous_fct_env.push(this.fct_env);
        this.fct_env = [];
    },
    leave_function_scope:function (type) {
        var vs = [];
        for (id in this.scope) {
            if (this.scope[id] === false) {
                if (type === "global")
                    vs.push(["set", ["get", id], ["get", "undefined"]]);
                else
                    vs.push(["var", id, ["get", "undefined"]]);
            }
        }

        var fcts = [];
        for (var i = 0; i < this.fct_env.length; ++i) {
            var fctStmt = this.fct_env[i];
            fcts.push(["set", ["get", fctStmt[0]], fctStmt[1]]);
        }
        this.scope   = this.previous_scopes.pop();
        this.fct_env = this.previous_fct_env.pop();
        return [[#begin].concat(vs), [#begin].concat(fcts)];
    },
    declare:function (id) {
        if (this.scope[id] === undefined) {
            this.scope[id] = false;
        }
    },
    args:function (ids) {
        for (var i = 0; i < ids.length; ++i) {
            this.scope[ids[i]] = true;
        }
    },
    replace_arguments:function (args) {
        return args.map(function (x) {
            return (x === "arguments") ? "$arguments" : x;
        });
    }
};

// ----------------------------------------------------------------------------
//
//
//                              Variable Scope resolution
//
//
// ----------------------------------------------------------------------------
ometa PhotonVarAnalysis <: PhotonASTTraversal {
  global   :ctxt {ctxt.scope = scope(null); self._ctxt.push(ctxt);} trans {ctxt.scope.resolve(); /*print(ctxt.scope);*/},
  get      (#true | #false | #undefined | #null | #$arguments -> { var a = self.scope().lookup("$arguments"); if (a === undefined || !a.isParam) { self.scope().set_use_arguments(); }}),
  get      :x {self.scope().use(x);},
  var      :name {self.scope().declare(name, false);} trans,

  func     :args 
           :ctxt {ctxt.scope = scope(self.scope()); self._ctxt.push(ctxt); self.add_args(args);}
           trans {self._ctxt.pop();}, 
  try      :ctxt  trans
           :name  {ctxt.scope = let_scope(self.scope(), [name]); self._ctxt.push(ctxt);}
           trans {self._ctxt.pop();}
           trans,
  letvar   [#var :name trans] -> name,
  let      :ctxt 
           [#begin letvar*:ns]
           {ctxt.scope = let_scope(self.scope(), ns); self._ctxt.push(ctxt);}
           trans {self._ctxt.pop()}
}

PhotonVarAnalysis.initialize = function () { 
    this._ctxt = []; 
    this.scope = function () { return this._ctxt[this._ctxt.length - 1].scope; };
    this.print_scope = function ()
    {
        for (var p in this.scope()) 
        { 
            print("var " + p + " is " + this.scope()[p]);
        } 
    };
    
    this.add_args = function (args)
    {
        for (var i = 0; i < args.length; ++i) 
        { 
            this.scope().declare(args[i], true);
        } 
    };
};

ometa PhotonVarScopeBinding <: PhotonASTCopy {
  isGlobal    :x = ?{x.is_global()},
  isLocal     :x = ?{x.is_local()},
  isEscaping  :x = ?{self.context.scope.escaping(x.id) === x},
  isCaptured  :x = ?{self.context.scope.captured(x.id) === x},


  global :ctxt   {self.context.enter_function_scope(ctxt.scope)} 
         trans:r {self.context.leave_function_scope(ctxt.scope)} -> [#global, ctxt, r], 

  get       (#true | #false | #undefined | #null | ?{self.context.is_local_scope()} #arguments):c -> [#get, c],
  get (:id -> {var x = self.context.scope.lookup(id); if (x === undefined) throw "Undefined variable '" + id + "'"; x}):x 
                                       ( isGlobal(x)             -> [#send, "__get__", [#ref, "root_global"], [#string, id]]
                                       | empty                   -> [#get, id]
                                       /*
                                       | isLocal(x)              -> [#get, id]
                                       | isEscaping(x)           -> [#getCell, id]
                                       | isCaptured(x)           -> [#closureRefValue, [#closure], [#number, self.context.closure_offsets[id]]]
                                       */),

  call ( [#get :id] ({self.context.scope.lookup(id);}):x ?{x.is_global()} 
         trans*:args                                             -> [#send, id, [#ref, "root_global"]].concat(args)
       | ^call),

  set       ([#get :id] ({self.context.scope.lookup(id)}):x 
            isGlobal(x) trans:val                                -> [#send, "__set__", [#ref, "root_global"], [#string, id], val]
            | ^set),
  func      :args :ctxt 
            {self.context.enter_function_scope(ctxt.scope);} // ctxt.scope.escaping()}:es
            //{ctxt.scope.captured()}:cs
            //{self.context.closure_offsets}:os
            trans:body
            {self.context.leave_function_scope();}               -> { 
                                                                      /*
                                                                      body = [#begin]
                                                                             .concat([body[1]])
                                                                             //.concat(self.context.gen_escaping(es))
                                                                             //.concat(self.context.gen_arguments(args.length, ctxt.scope))
                                                                             .concat(body.slice(2));

                                                                      var capturing = false; 
                                                                      for (var id in cs) {
                                                                          capturing = true; 
                                                                          break;
                                                                      }

                                                                      if (capturing) {
                                                                          var f = gensym();
                                                                          var fun = [#let, {scope:local_let_scope(self.context.scope, [f])},
                                                                             [#begin, [#var, f, [#func, args, ctxt, body]]],
                                                                             [#begin]
                                                                             .concat(self.context.gen_cell_capture(cs, os, f))
                                                                             .concat([[#get, f]])];
                                                                      } else {
                                                                          var fun = [#func, args, ctxt, body];
                                                                      }
                                                                      fun;
                                                                      */
                                                                      [#func, args, ctxt, body];
                                                                     },
  try :ctxt trans:x :name 
            {self.context.enter_let_scope(ctxt.scope)} 
            {self.context.scope._escaping}:es
            trans:c 
            {self.context.leave_let_scope(ctxt.scope)} 
            trans:f                                              -> [#try, ctxt, x, name, [#begin].concat(self.context.gen_escaping(es)).concat(c.slice(1)), f],
  letvar :s [#var :name trans:val] ( ?{s._escaping[name] !== undefined} -> [#var, name, [#send, "__new__", [#ref, "root.cell"], val]]
                                   |                                    -> [#var, name, val]), 
  let :ctxt [#begin letvar(ctxt.scope)*:vs]
            {self.context.enter_let_scope(ctxt.scope)} 
            trans:body 
            {self.context.leave_let_scope(ctxt.scope)}           -> [#let, ctxt, [#begin].concat(vs), body]
}

PhotonVarScopeBinding.initialize = function ()
{
    this.context = PhotonVarScopeBinding.context.init();
};

PhotonVarScopeBinding.context = 
{
    init:function () 
    { 
        var that = Object.create(PhotonVarScopeBinding.context);

        // Maintain the current scope and associated variables
        that.scope = null;
        that.previous_scopes = [];

        // Maintain the current closure offsets
        that.closure_offsets = null;
        that.previous_closure_offsets = [];
        that.closure_offset_begin = 0;


        return that;
    },
    enter_function_scope:function (scope)
    {
        this.previous_scopes.push(this.scope);
        this.scope = scope;

        this.previous_closure_offsets.push(this.closure_offsets);

        this.closure_offsets = {};
        var i = this.closure_offset_begin;
        for (var id in scope.captured())
        {
            this.closure_offsets[id] = i++; 
        }
    },
    leave_function_scope:function (scope)
    {
        this.scope           = this.previous_scopes.pop();
        this.closure_offsets = this.previous_closure_offsets.pop();
    },
    enter_let_scope:function (scope)
    {
        this.previous_scopes.push(this.scope);
        this.scope = scope;
    },
    leave_let_scope:function (scope)
    {
        this.scope = this.previous_scopes.pop();
    },
    gen_local:function (ls)
    {
        return ls.map(function (l) { return ["var", l.id, ["get", "undefined"]]; });
    },
    gen_escaping:function (es)
    {
        var a = [];
        for (id in es)
        {
            var v = es[id];

            if (v.scope.useArguments && v.isParam)
            {
                continue;
            }

            a.push(["set", ["get", id], ["send", "__new__", ["ref", "root.cell"], ["get", id]]]);
        }
        return a;
    },
    gen_cell_capture:function (cs, os, f)
    {
        var a = [];
        for (id in cs)
        {
            if (this.scope.escaping(id) !== undefined)
            {
                a.push(["set", ["closureRef", ["get", f], ["number", os[id]]], ["get", id]]);
            } else 
            {
                a.push(["set", 
                            ["closureRef", ["get", f], ["number", os[id]]], 
                            ["closureRef", ["closure"], ["number", this.closure_offsets[id]]]]);
            }
        }
        return a;
    },
    gen_arguments:function (expected_nb, scope)
    {
        if (scope.useArguments)
        {
            var i = gensym(), c = gensym(); length = gensym(); args = gensym();

            function args_get(index)
            {
                return ["igetp", ["get", args], ["binop", "+", index, ["number", 2]]];
            }

            return [["let", {scope:local_let_scope(scope, [i, c])},
                ["begin", ["var", i, ["number", 0]], ["var", c, ["get", "undefined"]], ["var", length, ["arguments_length"]], ["var", args, ["ref", "arguments"]]],
                ["begin",
                    ["set", ["get", "$arguments"], ["send", "__new__", ["ref", "root.arguments"], ["get", length]]],
                    ["for", 
                        ["begin", ["set", ["get", i], ["number", 0]]],
                        ["binop", "<", ["get", i], ["get", length]],
                        ["begin", ["set", ["get", i], ["binop", "+", ["get", i], ["number", 1]]]],
                        ["begin",
                            ["set", ["get", c], ["send", "__get_cell__", ["get", "$arguments"], ["get", i]]],
                            ["set", ["getCell", c], args_get(["get", i])],
                            ["set", args_get(["get", i]), ["get", c]]]],
                    ["for", 
                        ["begin", ["set", ["get", i], ["get", length]]],
                        ["binop", "<", ["get", i], ["number", expected_nb]],
                        ["begin", ["set", ["get", i], ["binop", "+", ["get", i], ["number", 1]]]],
                        ["begin",
                            ["set", args_get(["get", i]), ["send", "__new__", ["ref", "root.cell"], args_get(["get", i])]]]],
                     ["get", "undefined"]]]];
        } else
        {
            return [];
        }
    },
    is_local_scope:function ()
    {
        return this.previous_scopes.length !== 1;    
    }
};


// ----------------------------------------------------------------------------
//
//
//                              Code Generation
//
//
// ----------------------------------------------------------------------------
ometa PhotonLetConv <: PhotonASTCopy {
  trans      = [:t apply(t):ans]    -> ans,
  letvars  [#begin ([#var :name trans:val] -> [name, val])*:es] -> es,
  let      :ctxt letvars:es trans:body                          -> [#letLambda, self.names(es), self.values(es), self.bodyConv(body)] 
}
PhotonLetConv.initialize = function () {
  this.names = function (es)
  {
    return es.map(function (x) { return x[0]; });
  }
  this.values = function (es)
  {
    return es.map(function (x) { return x[1]; });
  }
  this.stmts = {"if":true, "while":true, "for":true, "forIn":true, "try":true, "switch":true, "with":true};
  this.bodyConv = function (body)
  {
    var last = body[body.length - 1];

    if (this.stmts[last[0]])
    {
        return body.concat([#return, [#get, "undefined"]]);
    } else
    {
        body[body.length - 1] = [#return, last];
        return body;
    }
  }
}

ometa PhotonICConv <: PhotonASTCopy {
  trans      = [:t apply(t):ans]       -> ans,
  send     :msg?(msg === "__$call__" || msg === "__$apply__") trans:recv trans*:args 
                                       -> [#send, msg, recv].concat(args),
  send     :msg 
           trans:recv trans*:args      -> {var nb = PhotonICConv.icCount++;
                                           var argTypes = [recv[0].toProgramString()].concat(args.map(function (x) { return x[0].toProgramString(); }));
                                           this.global_scope.push([#set, [#get, "codeCache"+nb], [#code, "initState"]], 
                                                                  [#set, [#get, "dataCache"+nb], [#code, "["+nb+","+msg.toProgramString()+",["+argTypes.join(",")+"]]"]]);
                                           [#icSend, nb, msg, recv].concat(args)},
  call     trans:fn trans*:args        -> {var nb = PhotonICConv.icCount++; var msg = "call";
                                           this.global_scope.push([#set, [#get, "codeCache"+nb], [#code, "initState"]], 
                                                                  [#set, [#get, "dataCache"+nb], [#code, "["+nb+","+msg.toProgramString()+",[]]"]]);
                                           [#icSend, nb, msg, fn, [#ref, "root_global"]].concat(args)},
  func     :args :ctxt trans:body      -> {var nb = PhotonICConv.icCount++; var msg = "__new__";
                                           this.global_scope.push([#set, [#get, "codeCache"+nb], [#code, "initState"]], 
                                                                  [#set, [#get, "dataCache"+nb], [#code, "["+nb+","+msg.toProgramString()+",[]]"]]);
                                           [#icSend, nb, msg, [#ref, "root.function"], [#func, args, ctxt, body]]},  
  json   trans*:props                  -> {var objPayloadName = "objPayload" + PhotonICConv.objPayloadCount++;
                                           var nb = PhotonICConv.icCount++; 
                                           var propNames  = props.map(function (b) { return b[1]; });
                                           var propValues = props.map(function (b) { return b[2]; }); 

                                           var args = [];
                                           var stmts = [];
                                           var propNamesStr = [];
                                           for (var i = 0; i < propNames.length; ++i) {
                                               args.push("x" + i);
                                               var str = propNames[i][1].toProgramString();
                                               stmts.push("    this["+str+ "] = x" + i)
                                               propNamesStr.push(str);
                                           }
                                           var fn = "function (" + args.join(",") + ") {\n" + stmts.join(";\n") + ";\n}";
                                           var objCreatePre  = "root.object.createWithPayloadAndMap(new " + objPayloadName;
                                           var objCreatePost = ", " + objPayloadName + ".map)";

                                           this.global_scope.push([#set, [#get, objPayloadName], [#code, fn]], 
                                                                  [#set, [#code, objPayloadName+".prototype"], [#code, "root.object.payload"]],
                                                                  [#set, [#code, objPayloadName+".map"], [#code, "getMap(root.object.newMap, [" + propNamesStr.join(",") + "])"]],
                                                                  [#set, [#get, "codeCache"+nb], [#code, "initState"]], 
                                                                  [#set, [#get, "dataCache"+nb], [#code, "["+nb+", "+"__new__".toProgramString()+",[]]"]]);
                                           [#icSend, nb, "__new__", [#ref, "root.object"], [#wrapExpr, objCreatePre, objCreatePost, [#exprSeq].concat(propValues)]];},
  arr      trans*:xs                    -> {var nb = PhotonICConv.icCount++; var msg = "__new__";
                                           this.global_scope.push([#set, [#get, "codeCache"+nb], [#code, "initState"]], 
                                                                  [#set, [#get, "dataCache"+nb], [#code, "["+nb+","+msg.toProgramString()+",[]]"]]);
                                           [#icSend, nb, msg, [#ref, "root.array"], [#wrapExpr, "(new ArrayProxy(", "))", [#arr].concat(xs)]]},
  global :ctxt trans:r                  -> [#global, ctxt, [#begin, [#begin].concat(this.global_scope), r]]
}

PhotonICConv.initialize = function () {
    this.global_scope = [];
}

PhotonICConv.icCount = 0;
PhotonICConv.objPayloadCount = 0;


ometa PhotonJSCodeGen {
  trans      = [:t apply(t):ans]    -> ans,
  flatten :a = [#begin flatten(a)*]
               | stmt:x                     -> a.push((self.ilvl() + x + "\n"))
               | trans:x                    -> a.push((self.ilvl() + x + ";\n")),
  flat       = {[]}:stmts flatten(stmts)*     -> stmts.join(""),
  stmt       = [:t isStmt(t) apply(t):ans]    -> ans,
  isStmt :t  = ?(self.stmts[t] !== undefined),
  block      = inc blockBody:body dec -> (self.ilvl() + "{\n" + body + self.ilvl() + "}"),
  blockBody  = [:t ?(t === "begin") apply("begin"):ans] -> ans
               | stmt:x                                 -> (self.ilvl() + x + "\n")
               | trans:x                                -> (self.ilvl() + x + ";\n"),
  exprList   = [#begin ([#var :name trans:val] -> (name + " = " + val))*:es] -> ((es.length) > 0 ? ("var " + es.join(", ")) : "")
             | [#begin trans*:es]                                            -> es.join(", "),
  inc        = { self.i++; },
  dec        = { self.i--; },
  
  global   :ctxt trans:r                                           -> r,
  var      :name trans:v                                           -> ("var " + name + " = " + v),
  this end                                                         -> "$this", 
  break end                                                        -> "break", 
  continue end                                                     -> "continue",
  number   :n                                                      -> String(n),
  regexp   :str_e                                                  -> ("(" + str_e + ")"),
  string   :s                                                      -> s.toProgramString(),
  unop     :op trans:x                                             -> ("(" + op + " " +  x + ")"),
  get      "arguments"                                             -> ("$arguments"),
  get      :x                                                      -> x,
  getCell  :x                                                      -> ("(" + x + ".payload)"),
  closure                                                          -> "$closure",
  closureRef trans:fn trans:offset                                 -> ("(" + fn + ".payload.cells[" + offset + "])"),
  set      [#closureRef trans:fn trans:offset] trans:rhs           -> ("(" + fn + ".payload.cells[" + offset + "] = " + rhs + ")"),
  closureRefValue trans:fn trans:offset                            -> ("(" + fn + ".payload.cells[" + offset + "].payload)"),
  set      [#closureRefValue trans:fn trans:offset] trans:rhs      -> ("(" + fn + ".payload.cells[" + offset + "].payload = " + rhs + ")"),
  set      trans:lhs trans:rhs                                     -> ("(" + lhs +  " = " +  rhs + ")"),
  binop    :op trans:x trans:y                                     -> ("(" + x +  " " +  op +  " " +  y + ")"),
  return   trans:x                                                 -> ("return " +  x),
  with     trans:x block:s                                         -> ("with (" +  x +  ")\n" +  s),
  if       trans:cond block:t block:e                              -> ("if (" +  cond +  ")\n" + t + " else\n" + e),
  condExpr trans:cond trans:t trans:e                              -> ("((" +  cond +  ") ? " +  t +  " : " +  e + ")"),
  while    trans:cond block:body                                   -> ("while (" +  cond +  ")\n" +  body),
  doWhile  block:body trans:cond                                   -> ("do \n" +  body +  "while (" +  cond +  ")"),
  for      exprList:init trans:cond exprList:upd block:body        -> ("for (" +  init +  "; " +  cond +  "; " +  upd +  ")\n" +  body),
  begin    flat:stmts                                              -> stmts,
  func     :args :ctxt block:body                                  -> ("(new FunctionProxy(function (" + ["$this", "$closure"].concat(args).join(",") +  ")\n" + body + "))"),
  call     trans:fn trans*:args                                    -> { var n = gensym();
                                                                        ("(function ("+n+") {" + "return send(" + [n, '"call"', "root_global"].concat(args).join(", ") +  ");})(" + fn + ")")},
  send     #__$call__  trans:recv trans*:args                      -> {var syms = args.map(function (x) { return gensym(); }); 
                                                                      ("(function (" + ["$closure"].concat(syms).join(", ") + ") {" + "return $closure.payload.code(" + 
                                                                            [syms[0], "$closure"].concat(syms.slice(1)).join(", ") +  
                                                                       ");})(" + [recv].concat(args).join(", ") +  ")")},
  send     #__$apply__ trans:recv trans*:args                      -> ("__$apply__(" + recv + ", " + args[0] + ", " + args[1] +  ")"),
  send     :msg trans:recv trans*:args                             -> ("send(" + [recv, '"' + msg + '"'].concat(args).join(", ") +  ")"),
  icSend   :nb :msg trans:recv trans*:args                         -> ("(codeCache"+nb + "(" + [recv, "dataCache"+nb].concat(args).join(", ") + "))"),
  throw    trans:x                                                 -> ("throw " +  x),
  try      :ctxt block:x :name ?(name === undefined) block:c block:f -> ("try\n" + x + " finally\n" + f ),
  try      :ctxt block:x :name block:c block:f                     -> ("try\n" + x + " catch (" + name + ")\n" + c + "finally\n" + f),
  switch   trans:x inc trans*:cases dec                            -> ("switch (" +  x +  ")\n" +  self.ilvl() +  "{\n" +  cases.join("\n") +  self.ilvl() +  "}"),
  case     trans:x inc block:y dec                                 -> (self.ilvl() + "case " + x + ":\n" + y),
  default          inc block:y dec                                 -> (self.ilvl() + "default:\n" +  y),
  exprSeq  trans*:es                                               -> ("(" + es.join(", ") + ")"),
  arr      trans*:xs                                               -> ("([" + xs.join(",") + "])"),

  ref      :s                                                      -> s,
  code     :c                                                      -> c,
  letLambda :args [trans*:values] block:body                       -> ("(function (" + args.join(",") + ")\n" + body + ")(" + values.join(",") + ")"),
  postcode trans:x :s                                              -> ("(" + x + s + ")"),
  precode  :s trans:x                                              -> ("(" + s + x + ")"),
  arguments_length                                                 -> ("(arguments.length - 2)"),
  arguments trans:i                                                -> ("(arguments[" + i + "+2])"),
  arguments_slice trans:i                                          -> ("arr(Array.prototype.slice.call(arguments, " + i + "+2))"),
  igetp    trans:x trans:fd                                        -> ("(" + x + "[" + fd + "])"),
  wrapExpr :pre :post trans:e                                      -> ("(" + pre + e + post + ")")
}

PhotonJSCodeGen.initialize = function () {
    this.i     = 0;
    this.sp    = [""];
    this.stmts = {"if":true, "while":true, "for":true, "forIn":true, "try":true, "switch":true, "with":true};
    this.ilvl  = function () {
        while (this.i >= this.sp.length) { 
            this.sp.push(this.sp[this.sp.length - 1] + "    "); 
        } 
        return this.sp[this.i];
    };
};
